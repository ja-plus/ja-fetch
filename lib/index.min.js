function createUrlParamStr(e,t){let r=new URL(e,window.location);for(const o in t)r.searchParams.append(o,t[o]);return r.href}function coreFetch(e,t){var r=t.params;if(r&&(e=createUrlParamStr(e,r)),t.body&&!(t.body instanceof FormData)&&"object"==typeof t.body){t.headers=Object.assign({"Content-Type":"application/json"},t.headers||{});try{t.body=JSON.stringify(t.body)}catch(e){throw new Error("cannot stringify body json")}}return t.credentials||(t.credentials="same-origin"),fetch(e,t)}class Interceptor{store=[];use(e,t){if(e&&"function"!=typeof e)throw new TypeError("interceptor.use(onFulfilled, onRejected), parameter onFulfilled is not a function");if(t&&"function"!=typeof t)throw new TypeError("interceptor.use(onFulfilled, onRejected), parameter onRejected is not a function");this.onFulfilled=e,this.onRejected=t;var r=Date.now();return this.store.push({id:r,onFulfilled:e,onRejected:t}),r}remove(t){t?this.store=this.store.filter(e=>e.id===t):(console.warn("Remove all Interceptor"),this.store=[])}}class Interceptors{request=new Interceptor;response=new Interceptor;use(e){const t=new Interceptors;e.install(t),t.request.store.forEach(e=>{this.request.use(e.onFulfilled,e.onRejected)}),t.response.store.forEach(e=>{this.response.use(e.onFulfilled,e.onRejected)})}create(){return new Interceptors}}class Service{defaultConf={headers:{}};interceptors=new Interceptors;constructor(e){this.defaultConf=Object.assign({},this.defaultConf,e)}create(e){return new Service(e)}#requestAdapter(t,e){const o=this.interceptors.request,n=this.interceptors.response;let s=Object.assign({},this.defaultConf,e);return o.store.length&&(s.headers||(s.headers={}),o.store.forEach(e=>{e=e.onFulfilled(t,s);e&&(s=e)})),coreFetch(t,s).then(r=>{if(r.ok){var t=s.responseType;let e;return e="blob"===t?r.blob():"text"===t?r.text():"arraybuffer"===t?r.arrayBuffer():"response"===t?r:r.json(),n.store.forEach(t=>{e=e.then(e=>t.onFulfilled(e,s,r),e=>t.onRejected?t.onRejected(e):Promise.reject(e))}),e}{const o={msg:"res status:"+r.status,config:s};let t=Promise.reject(o);return n.store.forEach(e=>{t=t.catch(e.onRejected).then(e=>e instanceof Promise?e:(console.warn("response.interceptor.use(onFulfilled, onRejected): onRejected function not return Promise. Use Promise.reject() to jump to next response interceptor's onRejected Function"),Promise.reject(o)))}),t}},e=>{const t={err:e,config:s};let r=Promise.reject(t);return o.store.forEach(e=>{r=r.catch(e.onRejected).then(e=>e instanceof Promise?e:(console.warn("request.interceptor.use(onFulfilled, onRejected): onRejected function not return Promise. Use Promise.reject() to jump to next request interceptor's onRejected Function"),Promise.reject(t)))}),r})}get(e,t={}){return t.method="GET",this.#requestAdapter(e,t)}post(e,t={}){return t.method="POST",this.#requestAdapter(e,t)}put(e,t={}){return t.method="PUT",this.#requestAdapter(e,t)}del(e,t={}){return t.method="DELETE",this.#requestAdapter(e,t)}}let service=new Service;export{service as default};
//# sourceMappingURL=index.min.js.map
